template<typename T>
btree<T>::btree(size_t maxNodeElems	) :
    maxSize(maxNodeElems), root_(std::shared_ptr<Node>()),head_(nullptr), tail_(nullptr), totalSize{0} {}

template<typename T>
btree<T>::~btree() {
  root_.reset();
}


// copy constructor
template<typename T>
btree<T>::btree(const btree<T>& original) : 
	maxSize(original.maxSize), 
	root_(copyNode(original.root_, nullptr)), 
	head_(findHead(root_.get())), 
	tail_(findTail(root_.get())), 
	totalSize(original.totalSize) {}

// move constructor
template<typename T>
btree<T>::btree(btree<T>&& original) : 
	maxSize(original.maxSize), 
	root_(copyNode(original.root_, nullptr)), 
	head_(findHead(root_.get())), 
	tail_(findTail(root_.get())), 
	totalSize(original.totalSize) {~original();}

// copy assignment
template<typename T> btree<T>& btree<T>::operator=(const btree<T>& rhs) {
	if (this != &rhs) {
		maxSize = rhs.maxSize;
		root_ = copyNode(rhs.root_, nullptr);
		head_ = findHead(root_.get());
		tail_ = findTail(root_.get());
		totalSize = rhs.totalSize;
	}
	return *this;
}

// move assignment
template<typename T> btree<T>& btree<T>::operator=(btree<T>&& rhs) {
	if (this != &rhs) {
		maxSize = rhs.maxSize;
		root_ = copyNode(rhs.root_, nullptr);
		head_ = findHead(root_);
		tail_ = findTail(root_);
		totalSize = rhs.totalSize;
		~rhs();
	}
	return *this;
}

template<typename T> std::ostream& operator<<(std::ostream& os, const btree<T>& tree) {
	std::vector<typename btree<T>::Node *> curr;
	std::vector<typename btree<T>::Node *> next;

	curr.push_back(tree.root_.get());
	while (!curr.empty()) {
		typename vector<typename btree<T>::Node *>::const_iterator iter;
		for (iter = curr.begin(); iter != curr.end(); ++iter) {
			typename btree<T>::Node * n = *iter;
			size_t i = 0;
			for (i = 0; i < n->getSize(); ++i) {
				os << n->getVal(i) << " ";
				if (n->getChild(i) != nullptr)
					next.push_back(n->getChild(i).get());
			}
			if (n->getChild(i) != nullptr) 
				next.push_back(n->getChild(i).get());
		}
		curr = next;
		next.clear();
	}
	return os;
}

template<typename T> const typename std::shared_ptr<typename btree<T>::Node> btree<T>::copyNode(std::shared_ptr<Node> src,  std::shared_ptr<Node> parent)  {
	std::shared_ptr<Node> n = std::make_shared<Node>(Node{maxSize, parent});
	for(size_t i = 0; i < src->getSize(); ++i) {
		n->insertVal(src->getVal(i));
	}
	for (size_t i = 0; i < maxSize + 1; ++i) {
		if (src->getChild(i) != nullptr) {
			n->insertChildAt(copyNode(src->getChild(i), n), i);
		}
	}
	return n;
}

template<typename T> typename btree<T>::Node* btree<T>::findHead(Node* n) {
	if (n -> isFull()) {
		if (n -> getChild(0) == nullptr) {
			return n;
		} else {
			return findHead(n -> getChild(0).get());
		}
	}
	return n;
}

template<typename T> typename btree<T>::Node* btree<T>::findTail(Node* n) {
	if (n -> isFull()) {
		if (n -> getChild(maxSize) == nullptr) {
			return n;
		} else {
			return findTail(n -> getChild(maxSize).get());
		}
	}
	return n;
}

template <typename T> void btree<T>::Node::clear() noexcept {
	elems.clear();
	children.clear();
}

template<typename T> const size_t btree<T>::Node::findIndex(const Node* node) const {
	auto e = std::find_if(children.begin(), children.end(), [node] (auto e) {
		return node == e.get();
	});
	return std::distance(children.begin(), e);
}

template<typename T> const std::pair<int, bool> btree<T>::Node::findInsertIndex(const T& elem) const {
	auto e = std::find_if(elems.begin(), elems.end(), [elem] (auto e) {
		return elem < *e;
	});
	int idx = std::distance(elems.begin(), e);
	if (idx == 0) {
		if (*elems.at(0) == elem) {
			return make_pair(0, true);
		}
	} else {
		if (*elems.at(idx-1) == elem) {
			return make_pair(idx, true);
		}
	}
	return make_pair(idx, false);
}




template<typename T>
const auto btree<T>::Node::findInsert(const T& elem) {
	auto e = std::find_if(elems.begin(), elems.end(), [elem] (auto e) {
		return elem < *e;
	});
	// size_t idx = std::distance(elems.begin(), e);
	return e;
}

template<typename T> typename btree<T>::iterator btree<T>::find(const T& elem) {
	std::pair<Node*, size_t> result = findHelper(root_.get(), elem);
    if (elem == result.first->getVal(result.second)) {
    	return iterator(result.first, result.second);
    }
    return iterator(tail_, tail_->getSize()-1);
}

template<typename T> std::pair<typename btree<T>::Node*, size_t> btree<T>::findHelper(Node* node, const T& elem) {
	for (size_t i = 0; i < node->getSize(); ++i) {
		if (elem == node->getVal(i)) {
			return make_pair(node, i);
		} else if (elem > node->getVal(i)) {
			if (node -> getChild(i+1) != nullptr) {
				return findHelper(node->getChild(i+1).get(), elem);
			} else {
				return make_pair(node, node->getSize() - 1);
			}
		}
	}
	return make_pair(node, node->getSize() - 1);
}

template<typename T> std::pair<typename btree<T>::Node*, size_t> btree<T>::findHelper(Node* node, const T& elem) const {
	for (size_t i = 0; i < node->getSize(); ++i) {
		if (elem == node->getVal(i)) {
			return make_pair(node, i);
		} else if (elem > node->getVal(i)) {
			if (node -> getChild(i+1) != nullptr) {
				return findHelper(node->getChild(i+1).get(), elem);
			} else {
				return make_pair(node, node->getSize() - 1);
			}
		}
	}
	return make_pair(node, node->getSize() - 1);
}

template<typename T> typename btree<T>::const_iterator btree<T>::find(const T& elem) const {
	std::pair<Node*, size_t> result = findHelper(root_.get(), elem);
    if (elem == result.first->getVal(result.second)) {
    	return iterator(result.first, result.second);
    }
    return const_iterator(tail_, tail_->getSize()-1);
}


template<typename T> typename std::pair<typename btree<T>::iterator, bool> btree<T>::insertHelper(const T& elem, const std::shared_ptr<Node>& ptr) {
	int idx = ptr->findInsertIndex(elem).first;
	bool exist = ptr->findInsertIndex(elem).second;

	
	if (exist) {
		--totalSize;
		// std::cout << elem << " already existed and index is " <<  idx-1 << std::endl;
		return make_pair(iterator(ptr.get(), idx-1), false);
	}


	if (!ptr->isFull()) {
		ptr->insertValAt(ptr->findInsert(elem), elem);
		return make_pair(iterator(ptr.get(), idx), true);
	} else {
		if (ptr->getChild(idx) == nullptr) {
			std::shared_ptr<Node> n = std::make_shared<Node>(Node{maxSize, ptr});
			n->insertVal(elem);
			ptr->insertChildAt(n, idx);
			if (elem > tail_ -> getLargest()) {
				tail_ = n.get();
			}
			if (elem < head_ -> getVal(0)) {
				head_ = n.get();
			}

			return make_pair(iterator(n.get(), 0), true);
		} else {
			return insertHelper(elem, ptr->getChild(idx));
		}
	}
}

template<typename T> std::pair<typename btree<T>::iterator, bool>
btree<T>::insert(const T& elem) {
		// std::cout << elem << " top" << std::endl;
	++totalSize;
	if (root_ == nullptr) {	//empty graph
		std::shared_ptr<Node> n = std::make_shared<Node>(Node{maxSize});
		head_ = n.get();
		tail_ = n.get();
		root_ = n;
		root_ -> insertVal(elem);
		return make_pair(iterator(n.get()), true);
	} else {
		auto e = insertHelper(elem, root_);
		return e;
	}
}

template<typename T> typename btree<T>::reverse_iterator
btree<T>::rbegin() const {
	return reverse_iterator(end());
}

template<typename T> typename btree<T>::reverse_iterator
btree<T>::rend() const {
	return reverse_iterator(begin());
}

template<typename T> typename btree<T>::const_iterator
btree<T>::cbegin() const {
	return const_iterator(begin());
}

template<typename T> typename btree<T>::const_iterator
btree<T>::cend() const {
	return const_iterator(end());
}

template<typename T> typename btree<T>::const_reverse_iterator
btree<T>::crbegin() const {
	return const_reverse_iterator(end());
}

template<typename T> typename btree<T>::const_reverse_iterator
btree<T>::crend() const {
	return const_reverse_iterator(begin());
}


template<typename T> typename btree<T>::iterator
btree<T>::begin() const {
	return iterator(head_, 0);
}

template<typename T> void btree<T>::printAll() const {
	// std::cout << root_->getChild(1)->getVal(0) << std::endl;
  	for(btree<T>::iterator iter = this->begin(); iter != this->end(); ++iter) {
    	cout << "node " << *iter << endl;
    }
    std::cout << "head is " << head_ -> getVal(0) << std::endl;
    std::cout << "tail is " << tail_ -> getLargest() << std::endl;
    std::cout << "size of tree is " << totalSize << std::endl;
}

template<typename T> typename btree<T>::iterator
btree<T>::end() const {
	return iterator(tail_, tail_->getSize());
}

